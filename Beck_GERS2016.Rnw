\documentclass[serif]{beamer}
\usetheme{Boadilla}
\usepackage{graphicx}
\usepackage[draft]{animate}
\usepackage{breqn}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{shapes,arrows,positioning,shadows}
\usepackage{subfig}
\usepackage{pgf}
\usepackage{caption}

% change format of enumerated lists
\setbeamertemplate{enumerate items}[default]
\setbeamertemplate{navigation symbols}{}

% macros
\newcommand{\emtxt}[1]{\textbf{\textit{#1}}}

% change font size for figure captions
\setbeamerfont{caption}{size=\scriptsize}

% custom colors
<<mypal, echo = F, results = 'asis', cache = T>>=
pal <- function(x) RColorBrewer::brewer.pal(x, 'GnBu')
num_col <- 5

for(i in 1:num_col){
 
  col.nm <- paste0('mypal',i)
  hexa <- paste0(gsub('#', '', pal(5)[i]))
  cat(paste0('\\definecolor{', col.nm,'}{HTML}{',hexa,'}'))
  
}

bg_col <- pal(num_col)[1]

pdf('fig/back_tmp.pdf',bg = bg_col)
frame()
invisible(dev.off())
@

\tikzstyle{decision} = [diamond, draw, text width=6em, text badly centered, inner sep = 2pt, top color=white, bottom color=mypal3, drop shadow]
\tikzstyle{block} = [rectangle, draw, text width=10em, text centered, rounded corners, minimum height=3em, minimum width=8em, top color = white, bottom color=mypal4,  drop shadow]
\tikzstyle{declare} = [rectangle, draw, text width=10em, text centered, minimum height=3em, minimum width=8em, top color = white, bottom color=mypal5,  drop shadow]

% knitr setup
<<setup, include = F, cache = F>>=
# set global chunk options
library(knitr)
opts_chunk$set(fig.path='fig/', fig.align='center', fig.show='hold',message=F,echo=F,results='asis',dev='pdf',dev.args=list(family='serif'),fig.pos='!ht',warning=F)
options(replace.assign=T,width=90)
@

% dependent data
<<dep_dat, include = F, cache = F>>=
source('R/funcs.R')
library(ggplot2)
library(dplyr)
library(gridExtra)
library(grid)
library(purrr)
library(tidyr)
library(Hmisc)
library(ggrepel)
library(lubridate)
@

% get online bib file
<<echo = FALSE, cache = FALSE>>=
refs <- httr::GET('https://raw.githubusercontent.com/fawda123/refs/master/refs.bib')
refs <- rawToChar(refs$content)
writeLines(refs, con = file('refs.bib'))
@

% part of figure used on title page
<<title_fig, echo = F, results = 'hide', message = F, eval = T>>=
source('R/funcs.R')
library(ggplot2)
library(RColorBrewer)
data(shps)

seg <- shps[['seg_820.shp']] # 820 segment polygon
sgrass <- shps[['sgpts_2006_820.shp']] # 820 segment seagrass depth point
# sgrass <- sgrass[sample(1:nrow(sgrass), 2000, replace = F),]

set.seed(4321)
est_pts <- grid_est(seg, spacing = 0.02)
test_pt <- est_pts[27, ]

buff_pts <- buff_ext(sgrass, test_pt, buff = 0.02)

doc_in <- data.frame(buff_pts)
dat <- doc_est(doc_in)

# complete plot
pc <- plot(dat)
pdf('fig/doc_title.pdf', height = 4, width = 7, family = 'serif')
pc
dev.off()
@

\setbeamercolor{title}{fg=mypal5} % main title
\setbeamercolor{frametitle}{fg=mypal4, bg=mypal2} % frame titles
\setbeamercolor{structure}{fg=mypal4} % bottom banner
\setbeamercolor{normal text}{fg=mypal5}
\usebackgroundtemplate{\includegraphics[height=\paperheight,width=\paperwidth]{fig/back_tmp.pdf}}

\begin{document}

\title[Seagrass light requirements]{\textbf{Quantifying seagrass light requirements using an algorithm to spatially resolve depth of colonization}}
\author[M. Beck, J. Hagy, C. Le]{Marcus W. Beck, James D. Hagy III, Chengfeng Le}

\institute[USEPA]{USEPA National Health and Environmental Effects Research Laboratory, Gulf Ecology Division, \href{mailto:beck.marcus@epa.gov}{beck.marcus@epa.gov}, Phone: 8509342480}

\date{Nov. 4, 2016}

\titlegraphic{
\begin{minipage}{0.4\textwidth}
\includegraphics[width=\linewidth]{fig/titlegraphic.png}
\end{minipage}
\begin{minipage}{0.27\linewidth}
\vspace{0.05in}
\includegraphics[width=\linewidth]{fig/doc_title.pdf}
\end{minipage}
}

%%%%%%
\begin{frame}[shrink]
\vspace{0.2in}
\titlepage
\end{frame}

\section{Background}

%%%%%%
\begin{frame}{$\vcenter{\hbox{\includegraphics[width=0.05\paperwidth]{fig/epa_logo.png}}}$\hspace{0.07in}\textbf{Seagrasses and water quality}}
\begin{center}
Seagrasses are beneficial - healthy seagrass, healthy estuary \\~\\
\centerline{\includegraphics[width = 0.7\textwidth]{fig/sg_pic.png}}
\vspace{0.1in}
Seagrasses are sentinels of water quality \tiny \cite{Short96}
\end{center}
\vfill
\tiny
\hfill \href{https://www.flickr.com/photos/swimvixen2/3581613875/in/photostream/}{flickr.com/photos/swimvixen2}
\end{frame}

%%%%%%
\begin{frame}{$\vcenter{\hbox{\includegraphics[width=0.05\paperwidth]{fig/epa_logo.png}}}$\hspace{0.07in}\textbf{Seagrasses and water quality}}
\onslide<+->
Nutrient limits using seagrass depth-limit targets \tiny \cite{Steward07}\\~\\
\begin{columns}[T]
\begin{column}{0.45\textwidth}
\centerline{\includegraphics[width = 0.9\textwidth]{fig/irl_map.png}}
\end{column}
\begin{column}{0.45\textwidth}
\centerline{\includegraphics[width = 0.92\textwidth]{fig/irl_reg.png}}
\end{column}
\end{columns}
\end{frame}

%%%%%%
\begin{frame}{$\vcenter{\hbox{\includegraphics[width=0.05\paperwidth]{fig/epa_logo.png}}}$\hspace{0.07in}\textbf{Seagrasses and water quality}}
\onslide<+->
The maximum depth of colonization is a useful proxy of eutrophication \\~\\
Often used as a basis for establishing nutrient criteria \\~\\
\onslide<+->
\emtxt{Problem 1:} No consensus on the best way to measure depth of colonization \\~\\
\emtxt{Problem 2:} Plenty of data are available but standardized techniques have not been developed \\~\\
\onslide<+->
\begin{block}{Study objective}
Develop and apply an algorithm that uses geospatial data to describe relationships between seagrass depth limits, water clarity, and light requirements \scriptsize [Beck, Hagy, Le, in review]
\end{block}
\end{frame}

%%%%%%
\begin{frame}{$\vcenter{\hbox{\includegraphics[width=0.05\paperwidth]{fig/epa_logo.png}}}$\hspace{0.07in}\textbf{Seagrasses and water quality}}
\onslide<+->
\emtxt{Existing geospatial datasets} - coastal segments, seagrass areal coverage, bathymetry
\begin{columns}[T]
\begin{column}{0.5\textwidth}
<</segmap, fig.height = 4, fig.width = 4, echo = F, results = 'hold', cache = T>>=
data(segs)
data(FL_state)

par(mar = c(0, 0, 2, 0), family = 'serif')
sp::plot(FL_state, col = pal(5)[3])
sp::plot(segs, col = pal(5)[2], add = T)
title('Segment-based approach', line = 0, cex.main = 1.4)
@
\end{column}
\begin{column}{0.45\textwidth}
\centerline{\includegraphics[width = 0.8\textwidth]{fig/Charlotte_Estuary_Segments.jpg}}
\end{column}
\end{columns}
\end{frame}

%%%%%%
\begin{frame}{$\vcenter{\hbox{\includegraphics[width=0.05\paperwidth]{fig/epa_logo.png}}}$\hspace{0.07in}\textbf{Seagrasses and water quality}}
\onslide<+->
How can we estimate depth of colonization? \\~\\
\begin{columns}[T]
\onslide<+->
\begin{column}{0.32\textwidth}
\emtxt{1.} Pick a segment\\~\\
\centerline{\includegraphics[width = 0.9\textwidth]{fig/map820.png}}
\end{column}
\onslide<+->
\begin{column}{0.32\textwidth}
\emtxt{2.} Get seagrass area \\~\\
<</segsg, fig.height = 4, fig.width = 4, echo = F, results = 'hold', cache = T>>=
data(seg_820)
data(FL_cut)
data(bbend_sg_diss)

par(mar=c(0,0,0,0))
sp::plot(seg_820, border = 'white')
sp::plot(bbend_sg_diss, add = T, col = pal(5)[2], border = NA)
sp::plot(FL_cut, add = T, col = pal(5)[3])
sp::plot(seg_820, add = T)
@
\end{column}
\onslide<+->
\begin{column}{0.32\textwidth}
\emtxt{3.} Get depth points\\~\\
<</segpt, fig.height = 4, fig.width = 4, echo = F, results = 'hold', cache = T>>=
data(sgpts_820_2006)
data(seg_820)
data(FL_cut)
sgpts_820_2006 <- sgpts_820_2006[sample(1:nrow(sgpts_820_2006), 1000, replace = F),]

par(mar=c(0,0,0,0))
sp::plot(seg_820)
sp::plot(FL_cut, add = T, col = pal(5)[3])
points(sgpts_820_2006, col = scales::alpha(pal(5)[5], 0.5), pch =16, cex = 0.6)
@
\end{column}
\end{columns}
\vspace{0.15in}
\onslide<+->
\emtxt{4.} Match depth points with p/a of seagrass...
\end{frame}

<<doc_ex, echo = F, results = 'hide', message = F, eval = T>>=
source('R/funcs.R')
library(ggplot2)
library(RColorBrewer)
data(shps)

seg <- shps[['seg_820.shp']] # 820 segment polygon
sgrass <- shps[['sgpts_2006_820.shp']] # 820 segment seagrass depth point

set.seed(4321)
est_pts <- grid_est(seg, spacing = 0.02)
test_pt <- est_pts[27, ]

buff_pts <- buff_ext(sgrass, test_pt, buff = 0.02)

doc_in <- data.frame(buff_pts)
dat <- doc_est(doc_in)

# complete plot
pa <- plot(dat, baseonly = T)
pb <- plot(dat, logisonly = T)
pc <- plot(dat)
pdf('fig/doc_ex.pdf', height = 4, width = 7, family = 'serif')
pa
pb
pc
dev.off()
@

%%%%%%
\begin{frame}{$\vcenter{\hbox{\includegraphics[width=0.05\paperwidth]{fig/epa_logo.png}}}$\hspace{0.07in}\textbf{Seagrasses and water quality}}
Plot the distribution of seagrass by increasing depth \\~\\
\includegraphics<1>[width = \textwidth, page = 1]{fig/doc_ex.pdf}
\includegraphics<2>[width = \textwidth, page = 2]{fig/doc_ex.pdf}
\includegraphics<3>[width = \textwidth, page = 3]{fig/doc_ex.pdf}
\end{frame}

%%%%%%
\begin{frame}{$\vcenter{\hbox{\includegraphics[width=0.05\paperwidth]{fig/epa_logo.png}}}$\hspace{0.07in}\textbf{Seagrasses and water quality}}
\onslide<+->
The estimate depends on the spatial context...
\begin{columns}[T]
\onslide<+->
\begin{column}{0.45\textwidth}
<</docfail1, fig.height = 4, fig.width = 4, echo = F, results = 'hold', cache = T>>=
data(seg_820)
data(FL_cut)
data(sgpts_820_2006)
sgpts_820_2006 <- sgpts_820_2006[sample(1:nrow(sgpts_820_2006), 1000, replace = F),]
above <- sgpts_820_2006[sgpts_820_2006$GRID_CODE >= -2.619, ]
below <- sgpts_820_2006[sgpts_820_2006$GRID_CODE < -2.619, ]

par(mar=c(0,0,0,0))
sp::plot(seg_820, border = 'white')
sp::plot(FL_cut, add = T, col = pal(5)[3])
sp::plot(seg_820, add = T)
points(above, col = alpha(pal(5)[5], 0.5), pch = 16, cex = 0.6)
points(below, col = alpha('black', 0.5), pch = 21, cex = 0.6)
legend('bottomleft', legend = c('Within max depth estimate', 'Beyond max depth estimate'), col = c(alpha(pal(5)[5], 0.5), alpha('black', 0.5)), pch = c(16, 21), border = white)
@
\end{column}
\onslide<+->
\begin{column}{0.45\textwidth}
<</docfail2, fig.height = 4, fig.width = 4, echo = F, results = 'hold', cache = T>>=
data(seg_820)
data(FL_cut)
data(sgpts_820_2006)
data(bbend_sg_diss)
sgpts_820_2006 <- sgpts_820_2006[sample(1:nrow(sgpts_820_2006), 1000, replace = F),]
above <- sgpts_820_2006[sgpts_820_2006$GRID_CODE >= -2.619, ]
below <- sgpts_820_2006[sgpts_820_2006$GRID_CODE < -2.619, ]

par(mar=c(0,0,0,0))
sp::plot(seg_820, border = 'white')
sp::plot(FL_cut, add = T, col = pal(5)[3])
sp::plot(seg_820, add = T)
points(above, col = alpha(pal(5)[5], 0.5), pch = 16, cex = 0.6)
points(below, col = alpha('black', 0.5), pch = 21, cex = 0.6)
sp::plot(bbend_sg_diss, add = T, col = pal(5)[2], border = NA)
legend('bottomleft', legend = 'Actual seagrass growth', fill = alpha(pal(5)[2]), border = alpha(pal(5)[1]))
@
\end{column}
\end{columns}
\end{frame}

<<radani, eval = F, echo = F>>=
set.seed(4321)
data(shps)
seg <- shps[['seg_820.shp']] # 820 segment polygon
sgrass <- shps[['sgpts_2006_820.shp']] # 820 segment seagrass depth point
sgrass <- sgrass[sample(1:nrow(sgrass), 20000, replace = F),]
data(FL_cut)

test_pt <- data.frame(Var1 = -83.41391, Var2 =  29.63639)
test_pt <- SpatialPoints(test_pt)

# radii to eval
rads <- rev(seq(0.05, 0.2, length = 40))

# get doc by radius estimates for plot
ests <- NULL
for(rad in rads){

  buff_pts <- buff_ext(sgrass, test_pt, buff = rad)

  doc_in <- data.frame(buff_pts)
  dat <- doc_est(doc_in, maxbin = 0.5, minpts = 1000)
  dat <- attributes(dat)[[c('z_cmed')]]
  
  ests <- c(ests, dat)

}

# sample again for smaller plot
sgrass <- sgrass[sample(1:nrow(sgrass), 1000, replace = F),]

pdf('fig/radred.pdf', height = 5, width = 10, family = 'serif')
for(rad in rads){
  
  cat(rad, '\t')
  par(mfrow = c(1, 2), mar = c(6, 5, 1, 1), family = 'serif')

  buff_pts <- buff_ext(sgrass, test_pt, buff = rad)

  sp::plot(seg, border = 'white')
  sp::plot(FL_cut, add = T, col = pal(5)[3])
  sp::plot(seg, add = T)
  points(buff_pts, pch = 16, col = alpha(pal(5)[5], 0.5), cex = 0.6)
  points(test_pt, pch = 16, col = 'black', cex = 3)
  legend('bottomleft', legend = c('Pt of interest', 'Depth pts in buffer'), pch = c(16, 16), col = c('black', pal(5)[5]), pt.cex = c(3, 1))
  mtext(paste0("Radius from pt: ", round(rad, 2), " (dec. deg.)"), cex = 1.45, side = 1, line = 3)

  x <- rads
  y <- ests

  ind <- which(rad == rads)
  if(1 + ind > length(y)) y <- ests
  else y[(1 + ind):length(y)] <- NA
  plot(x, y, type = 'l', xlab = 'Radius from pt (dec. deg.)', ylab = 'Max depth estimate (m)', ylim = c(1, 2), xlim = rev(range(x)),
    bty = 'n', cex.lab = 1.45)
  points(rad, ests[ind], pch = 16, cex = 2)

}
dev.off()

@
%%%%%%
\begin{frame}{$\vcenter{\hbox{\includegraphics[width=0.05\paperwidth]{fig/epa_logo.png}}}$\hspace{0.07in}\textbf{Seagrasses and water quality}}
The estimate depends on the spatial context...
\begin{center}
\animategraphics[controls,width=\linewidth,trim = 15mm 2mm 0mm 0mm]{6}{fig/radred}{}{} %frame rate is 12 per/sec
\end{center}
\end{frame}

<<radani2, eval = F, echo = F>>=
# set.seed(4321)
# data(shps)
# seg <- shps[['seg_820.shp']] # 820 segment polygon
# sgrass <- shps[['sgpts_2006_820.shp']] # 820 segment seagrass depth point
# sgrass <- sgrass[sample(1:nrow(sgrass), 20000, replace = F),]
# 
# est_pts <- grid_est(seg, spacing = 0.025)
# 
# # radii to eval
# rads <- rev(seq(0.05, 0.15, length = 40))
# 
# rad_ests <- vector('list', length = length(rads))
# names(rad_ests) <- rads
# for(rad in rads){
#   cat(rad, '\t')
#   ests <- NULL
#   for(est_pt in 1:nrow(data.frame(est_pts))){
#   # get doc by radius estimates for plot
# 
#     buff_pts <- buff_ext(sgrass, est_pts[est_pt, ], buff = rad)
# 
#     buff_pts <- buff_ext(sgrass, est_pts[est_pt, ], buff = rad)
# 
#     doc_in <- data.frame(buff_pts)
#     dat <- doc_est(doc_in, maxbin = 0.5, minpts = 1000)
#     dat <- attributes(dat)[[c('z_cmed')]]
#   
#     ests <- c(ests, dat)
# 
#   }
# 
# rad_ests[[as.character(rad)]] <- ests
# 
# }

set.seed(1234)
load('data/rad_ests.RData')
est_pts <- grid_est(seg, spacing = 0.025)

# get colors for plotting
col_ests <- do.call('c', rad_ests)
col_ests <- colorRampPalette(pal(5)[c(3, 4, 5)])(length(col_ests))[rank(col_ests)]
col_ests <- split(col_ests, rep(rads, each = length(est_pts)))

# get sizes for plotting
rsc_ests <- do.call('c', rad_ests)
rsc_ests <- scales::rescale(rsc_ests, c(1, 5))
rsc_ests <- split(rsc_ests, rep(rads, each = length(est_pts)))

# legend stuff
leg.text<-round(quantile(do.call('c', rad_ests), c(0,0.33,0.66,1), na.rm = T),1)
leg.cex<-seq(1,5,length=4)
leg.col<-colorRampPalette(pal(5)[c(3, 4, 5)])(4)

# radii to eval
rads <- rev(seq(0.05, 0.15, length = 40))
cex_rads <- seq(100, 15, length = 40)

pdf('fig/radred2.pdf', height = 4.25, width = 9, family = 'serif')
for(rad in 1:length(rads)){

  cat(rad, '\t')
  par(mfrow = c(1, 2), mar = c(1, 1, 1, 1), family = 'serif')

  sp::plot(seg_820, border = 'white')
  sp::plot(FL_cut, add = T, col = pal(5)[3])
  sp::plot(seg_820, add = T)
  sp::plot(est_pts, add = T, pch = 16, col = 'black')
  sp::plot(est_pts, add = T, pch = 1, col = 'black', cex = cex_rads[rad])
  legend('bottomleft', pch = c(16, 1), pt.cex = c(1, 4), legend = c('Pt for estimate', 'Area around pt'), cex = 1.1, bty = 'n', bg = 'white', y.intersp=1.6)

  col_est <- col_ests[names(col_ests) %in% rads[rad]][[1]]
  rsc_est <- rsc_ests[names(rsc_ests) %in% rads[rad]][[1]]

  sp::plot(seg_820, border = 'white')
  sp::plot(FL_cut, add = T, col = pal(5)[3])
  sp::plot(seg_820, add = T)
  sp::plot(est_pts, add = T, pch = 16, col =col_est, cex = rsc_est)
  legend('bottomleft', legend=leg.text,pt.cex=leg.cex,col=leg.col,title='Maximum seagrass\ndepth (m)',pch=16,bty='n',cex=1.1,y.intersp=1.6,pt.bg=leg.col,x.intersp=1.3)

}
dev.off()
@

%%%%%%
\begin{frame}{$\vcenter{\hbox{\includegraphics[width=0.05\paperwidth]{fig/epa_logo.png}}}$\hspace{0.07in}\textbf{Seagrasses and water quality}}
The estimate depends on the spatial context...
\begin{center}
\animategraphics[controls,width=0.95\linewidth]{6}{fig/radred2}{}{} %frame rate is 12 per/sec
\end{center}
\end{frame}

<<>>=
# reset digits to default
data(tb_light)
data(tb_seg)
data(sgbuff_2010_tb)

# mask tb doc and light ests by 1km buffer of seagrass
coordinates(tb_light) = ~Longitude+Latitude
tmp <- tb_light  %over% sgbuff_2010_tb %>% 
  is.na(.) %>% 
  !.
tb_light <- data.frame(tb_light)[tmp, ]

# centroids for labels
labs <- data.frame(rgeos::gCentroid(tb_seg, byid = T))
labs$seg <- c('HB', 'LTB', 'MTB', 'OTB')

fill_col <- colors()[245]

# format data, remove outliers
dat <- data.frame(tb_light)
# outs <- quantile(dat$light, c(0.05, 0.95))
# dat <- dat[dat$light > outs[1] & dat$light < outs[2],]

# color ramp for all graphs
pt_cols <- c('blue', 'lightblue', 'yellow', 'brown')

# legend formatting, z_cmed
scls <- c(2, 9)
scl_vals <- scales::rescale(dat$z_c_all, to = scls)
leg_brks <- seq(min(dat$z_c_all, na.rm =  T), max(dat$z_c_all, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)

# map, z_cmed
p1 <- ggplot(fortify(tb_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = group)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = z_c_all), fill = 'black', alpha = 0.8) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(labels = fmt()) + 
  xlab('Longitude') +
  scale_y_continuous(labels = fmt()) + 
  ylab('Latitude') +
  scale_size(name = bquote(italic('Z' ['c, med']) ~ (m)), range = scls, 
    breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = bquote(italic('Z' ['c, med']) ~ (m)), 
    colours = rev(pt_cols),
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend())

# p1leg <- g_legend(p1)
p1 <- p1 + theme(#legend.position = 'none',
  axis.line.x = element_line(), 
  axis.line.y = element_line()
  )

# boxplots by seg, z_cmed
# reorder seg labels
segs <- c('LTB', 'MTB', 'HB', 'OTB')
dat$seg <- factor(dat$seg, levels = segs) 
p2 <- ggplot(dat, aes(x = seg, y = z_c_all)) + 
  stat_summary(fun.data = f, geom = "boxplot", fill = fill_col) + 
  stat_summary(fun.y = o, geom = "point") + 
  ylab(bquote(italic('Z' ['c, med']))) +
  theme_classic() +
  theme(axis.title.y = element_blank(),
    axis.line.x = element_line(), 
    axis.line.y = element_line()
  ) + 
  coord_flip()

# legend formatting, light requirements
scls <- c(2, 9)
scl_vals <- scales::rescale(dat$light, to = scls)
leg_brks <- seq(min(dat$light, na.rm =  T), max(dat$light, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)
  
# map, light requirements
p3 <- ggplot(fortify(tb_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = group)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = light), fill = 'black', alpha = 0.8) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(labels = fmt()) + 
  xlab('Longitude') +
  scale_y_continuous(labels = fmt()) + 
  ylab('Latitude') +
  scale_size(name = '% light\nrequirements', range = scls, breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = '% SI', 
    colours = pt_cols,
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend())

p3leg <- g_legend(p3)
p3 <- p3 + theme(legend.position = 'none',
  axis.line.x = element_line(), 
  axis.line.y = element_line()
  )

# boxplots, light requirements
p4 <- ggplot(dat, aes(x = seg, y = light)) + 
  stat_summary(fun.data = f, geom = "boxplot", fill = fill_col) + 
  stat_summary(fun.y = o, geom = "point") +
  ylab('% light requirements') +
  theme_classic() +
  theme(axis.title.y = element_blank(),
    axis.line.x = element_line(), 
    axis.line.y = element_line()
    ) + 
  coord_flip()

pdf('figs/Fig8.pdf', height = 7.5, width = 7, family = 'serif')
grid.arrange(p1, p1leg, p2, p3, p3leg, p4, ncol = 3, nrow = 2, 
  widths = c(1, 0.3, 0.75))
dev.off()
@

%%%%%%
\begin{frame}{$\vcenter{\hbox{\includegraphics[width=0.05\paperwidth]{fig/epa_logo.png}}}$\hspace{0.07in}\textbf{Seagrasses and water quality}}
Can we link depth estimates with water clarity to understand light requirements? 
$\%SI = 100 \cdot \frac{I_{z}}{I_{o}} = exp\left(-K_d \cdot Z_{c,med}\right)$
\end{frame}

% %%%%%%
\begin{frame}{\textbf{Case 2: Seagrass and water quality}}{\textbf{Making the most of existing data}}
\onslide<+->
Benefits of the approach: \\~\\
\begin{itemize}
\item The spatial unit for any estimate of seagrass growth limit is problem-specific \\~\\
\item Allows for a `compliance-point' approach (saves time/money) \\~\\
\item Increased understanding of seagrass growth patterns - natural and anthropogenic drivers \\~\\
\end{itemize}
\onslide<+->
Lots to be done...
\end{frame}

% %%%%%%
% \begin{frame}{\textbf{Case 2: Seagrass and water quality}}{\textbf{Making the most of existing data}}
% Development widget online: \href{https://beckmw.shinyapps.io/sg_depth/}{https://beckmw.shinyapps.io/sg\_depth/}
% \centerline{\includegraphics[width = 0.75\textwidth]{fig/widget.png}}
% \end{frame}
% 
% %%%%%%
% \begin{frame}
% Acknowledgments and contact info:\\~\\
% \begin{columns}
% \begin{column}{0.9\textwidth}
% {\footnotesize
% Research staff and employees at USEPA Gulf Ecology Division, San Francisco Estuary Institute \\~\\
% David Senn, Phil Bresnahan, Emily Novick, James D. Hagy III, Thomas Jabusch
% }
% \end{column}
% \end{columns}
% \vfill
% \begin{columns}
% \begin{column}{0.5\textwidth}
% \begin{center}
% \includegraphics[width=0.7\linewidth]{fig/titlegraphic.png}
% \end{center}
% \end{column}
% \begin{column}{0.5\textwidth}
% \scriptsize
% \begin{center}
% \href{mailto:beck.marcus@epa.gov}{beck.marcus@epa.gov} \\~\\
% Github @fawda123 \\~\\
% Phone: 8509342480
% \end{center}
% \end{column}
% \end{columns}
% \vfill
% Links:\\~\\
% \begin{columns}
% \begin{column}{0.9\textwidth}
% \scriptsize
% This presentation: \href{https://github.com/fawda123/sfei_pres}{\url{https://github.com/fawda123/sfei\_pres}}
% 
% Shiny app: \href{https://beckmw.shinyapps.io/sf_trends/}{\url{https://beckmw.shinyapps.io/sf_trends/}}
% 
% Detailed results: \href{http://fawda123.github.io/sf_trends/README}{\url{http://fawda123.github.io/sf\_trends/README}}
% \end{column}
% \end{columns}
% \end{frame}

%%%%%%
\section{References}
\begin{frame}[t]{\textbf{References}}
\tiny
\setbeamertemplate{bibliography item}{}
\bibliographystyle{apalike_mine}
\bibliography{refs}
\end{frame}

\end{document}